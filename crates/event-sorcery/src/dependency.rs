//! Type-level dependency lists and computed event types.
//!
//! This module provides the building blocks for declaring which
//! entities a reactor handles and computing the discriminated union
//! event type from that list. Both the [`Reactor`](super::Reactor)
//! trait and the [wiring infrastructure](super::StoreBuilder) depend
//! on these types.
//!
//! # Type-level lists
//!
//! Entity lists are built from [`Cons`] and [`Nil`]:
//! `Cons<A, Cons<B, Nil>>`. The [`deps!`] macro provides sugar:
//! `deps![A, B]`.
//!
//! # Computed event types
//!
//! [`EntityList`] computes a discriminated union event type from
//! the list. `Cons<A, Cons<B, Nil>>` yields
//! `OneOf<(A::Id, A::Event), OneOf<(B::Id, B::Event), Never>>`.
//!
//! Consume events via the [`.on()`](OneOf::on) /
//! [`.exhaustive()`](Fold::exhaustive) chain, which guarantees
//! at compile time that every entity is handled.

use std::future::Future;
use std::marker::PhantomData;
use std::pin::Pin;
use std::sync::Arc;

use crate::EventSourced;
use crate::lifecycle::Never;

/// Type-level cons cell for building linked lists of entities.
///
/// Forms a compile-time linked list:
/// `Cons<Position, Cons<TokenizedEquityMint, Nil>>`.
pub struct Cons<Head, Tail>(PhantomData<(Head, Tail)>);

/// Type-level empty list (nil).
///
/// Terminal element for type-level lists. When an [`Unwired`]
/// reaches this state, [`into_inner`](super::Unwired::into_inner)
/// becomes available.
pub struct Nil;

/// Declares which entities a reactor handles.
///
/// Generated by the statement-position form of [`deps!`]:
///
/// ```ignore
/// deps!(RebalancingTrigger, [Position, TokenizedEquityMint]);
/// ```
///
/// This also generates [`HasEntity`] impls for each entity,
/// enabling ergonomic [`ReactorHarness::receive`] calls.
pub trait Dependent: Send + Sync {
    /// Type-level list of entities this reactor handles.
    type Dependencies: EntityList;
}

/// Enables sharing a `Dependent` impl via `Arc`.
impl<R: Dependent> Dependent for Arc<R> {
    type Dependencies = R::Dependencies;
}

/// Trait on type-level entity lists that computes the
/// discriminated union event type.
///
/// `Cons<A, Cons<B, Nil>>` yields
/// `OneOf<(A::Id, A::Event), OneOf<(B::Id, B::Event), Never>>`.
pub trait EntityList {
    type Event: Send;
}

impl EntityList for Nil {
    type Event = Never;
}

impl<Head: EventSourced, Tail: EntityList> EntityList for Cons<Head, Tail> {
    type Event = OneOf<(Head::Id, Head::Event), Tail::Event>;
}

/// Discriminated union of entity events, computed from a
/// type-level entity list.
///
/// `Cons<A, Cons<B, Nil>>` yields
/// `OneOf<(A::Id, A::Event), OneOf<(B::Id, B::Event), Never>>`.
///
/// Consume via the [`.on()`](Self::on) chain:
///
/// ```ignore
/// event
///     .on(|id, event| async move { self.on_a(id, event).await })
///     .on(|id, event| async move { self.on_b(id, event).await })
///     .exhaustive()
///     .await
/// ```
pub enum OneOf<Head, Tail> {
    Here(Head),
    There(Tail),
}

impl<Id, Event, Tail> OneOf<(Id, Event), Tail> {
    /// Handle the head entity in the union.
    ///
    /// The handler returns a future, which is boxed to unify
    /// types across all handlers in the chain. Call
    /// [`.exhaustive()`](Fold::exhaustive) after all handlers,
    /// then `.await` the result.
    pub fn on<'a, T, F, Fut>(self, handler: F) -> Fold<BoxFuture<'a, T>, Tail>
    where
        F: FnOnce(Id, Event) -> Fut,
        Fut: Future<Output = T> + Send + 'a,
    {
        match self {
            OneOf::Here((id, event)) => Fold::Done(Box::pin(handler(id, event))),
            OneOf::There(tail) => Fold::Remaining(tail),
        }
    }
}

impl<A> OneOf<A, Never> {
    /// Unwrap a single-entity event.
    ///
    /// Convenience for `Dependencies = deps![Entity]` where the
    /// computed event is `OneOf<(Id, Event), Never>`.
    pub fn into_inner(self) -> A {
        match self {
            OneOf::Here(inner) => inner,
            OneOf::There(never) => match never {},
        }
    }
}

/// Intermediate result from folding handlers over a [`OneOf`]
/// chain.
///
/// `Done(T)` means a handler already matched. `Remaining(tail)`
/// means no handler matched yet and more `.on()` calls are
/// needed. When the tail is [`Never`],
/// [`.exhaustive()`](Self::exhaustive) extracts the result.
pub enum Fold<T, Remaining> {
    Done(T),
    Remaining(Remaining),
}

/// Boxed future used for type erasure across `.on()` handler chains.
type BoxFuture<'a, T> = Pin<Box<dyn Future<Output = T> + Send + 'a>>;

impl<'a, T, Id, Event, Tail> Fold<BoxFuture<'a, T>, OneOf<(Id, Event), Tail>> {
    /// Handle the next entity in the union.
    ///
    /// The handler returns a future, which is boxed to match
    /// the type established by the first `.on()` call.
    pub fn on<F, Fut>(self, handler: F) -> Fold<BoxFuture<'a, T>, Tail>
    where
        F: FnOnce(Id, Event) -> Fut,
        Fut: Future<Output = T> + Send + 'a,
    {
        match self {
            Fold::Done(fut) => Fold::Done(fut),
            Fold::Remaining(one_of) => match one_of {
                OneOf::Here((id, event)) => Fold::Done(Box::pin(handler(id, event))),
                OneOf::There(tail) => Fold::Remaining(tail),
            },
        }
    }
}

impl<T> Fold<T, Never> {
    /// Extract the result once all entities are handled.
    ///
    /// Only available when every entity in the chain has a
    /// corresponding `.on()` handler -- [`Never`] guarantees
    /// exhaustiveness at compile time.
    pub fn exhaustive(self) -> T {
        match self {
            Fold::Done(result) => result,
            Fold::Remaining(never) => match never {},
        }
    }
}

/// Type-level zero (Peano numeral).
///
/// Used by the wiring infrastructure to track how many entities
/// have been wired. Consumers never need to name this directly.
pub struct Zero;

/// Type-level successor (Peano numeral).
///
/// Used by the wiring infrastructure to track how many entities
/// have been wired. Consumers never need to name this directly.
pub struct Successor<N>(PhantomData<N>);

/// Inject an entity's (Id, Event) pair at a specific depth
/// in the computed event type.
///
/// Used internally by the wiring infrastructure. Consumers
/// never need to reference this trait directly.
pub trait InjectAtDepth<Depth>: EntityList {
    type EntityId;
    type EntityEvent;

    fn inject(id: Self::EntityId, event: Self::EntityEvent) -> Self::Event;
}

impl<Head: EventSourced, Tail: EntityList> InjectAtDepth<Zero> for Cons<Head, Tail> {
    type EntityId = Head::Id;
    type EntityEvent = Head::Event;

    fn inject(id: Head::Id, event: Head::Event) -> Self::Event {
        OneOf::Here((id, event))
    }
}

impl<Head: EventSourced, Tail: EntityList, N> InjectAtDepth<Successor<N>> for Cons<Head, Tail>
where
    Tail: InjectAtDepth<N>,
{
    type EntityId = <Tail as InjectAtDepth<N>>::EntityId;
    type EntityEvent = <Tail as InjectAtDepth<N>>::EntityEvent;

    fn inject(id: Self::EntityId, event: Self::EntityEvent) -> Self::Event {
        OneOf::There(<Tail as InjectAtDepth<N>>::inject(id, event))
    }
}

/// Inject an entity's (Id, Event) pair by entity type.
///
/// Generated by [`register_entities!`] for each entity in
/// the list. Enables `harness.receive::<MyEntity>(id, event)`
/// without specifying position indices or Peano depths.
pub trait HasEntity<Entity: EventSourced>: EntityList {
    fn inject(id: Entity::Id, event: Entity::Event) -> Self::Event;
}

/// Build a type-level dependency list from entity types.
///
/// Has two forms, distinguished by syntax:
///
/// ## Type-position: `deps![...]`
///
/// Expands to a nested `Cons<..., Nil>` type. Use for
/// `Unwired` type annotations and manual `Dependent` impls:
///
/// ```ignore
/// let reactor: Unwired<MyReactor, deps![A, B]> = ...;
/// ```
///
/// ## Statement-position: `deps!(Reactor, [...])`
///
/// Generates a [`Dependent`] impl (setting `Dependencies`)
/// and [`HasEntity`] impls for each entity. This is the
/// primary form -- the entity list is written once:
///
/// ```ignore
/// deps!(EventBroadcaster, [
///     TokenizedEquityMint,
///     EquityRedemption,
///     UsdcRebalance,
/// ]);
///
/// impl Reactor for EventBroadcaster {
///     // Dependencies comes from Dependent -- no duplication
///     type Error = Never;
///
///     async fn react(
///         &self,
///         event: <Self::Dependencies as EntityList>::Event,
///     ) -> Result<(), Self::Error> { ... }
/// }
/// ```
#[macro_export]
macro_rules! deps {
    // Statement-position: generate Dependent + HasEntity impls.
    ($reactor:ty, [$($entity:ty),+ $(,)?]) => {
        impl $crate::Dependent for $reactor {
            type Dependencies = $crate::deps![$($entity),+];
        }
        $crate::register_entities!($($entity),+);
    };

    // Type-position: expand to Cons chain.
    () => { $crate::Nil };
    ($head:ty $(, $tail:ty)* $(,)?) => {
        $crate::Cons<$head, $crate::deps![$($tail),*]>
    };
}

/// Generate [`HasEntity`] impls for each entity in a list.
///
/// This is the low-level building block used by the
/// statement-position form of [`deps!`]. Prefer using `deps!`
/// directly, which generates both [`Dependent`] and [`HasEntity`]
/// impls in one call.
///
/// Only use this directly for generic `Reactor` impls (like
/// [`SpyReactor`]) where `deps!` can't generate the `Dependent`
/// impl.
#[macro_export]
macro_rules! register_entities {
    ($($entity:ty),+ $(,)?) => {
        $crate::register_entities!(@impls [$($entity),+] [$($entity),+] []);
    };

    // All entities processed.
    (@impls [] [$($all:ty),+] [$($done:ty),*]) => {};

    // Generate HasEntity for the current entity, then recurse.
    (@impls [$current:ty $(, $rest:ty)*] [$($all:ty),+] [$($done:ty),*]) => {
        impl $crate::HasEntity<$current> for $crate::deps![$($all),+] {
            fn inject(
                id: <$current as $crate::EventSourced>::Id,
                event: <$current as $crate::EventSourced>::Event,
            ) -> <Self as $crate::EntityList>::Event {
                $crate::register_entities!(@wrap [$($done),*] $crate::OneOf::Here((id, event)))
            }
        }

        $crate::register_entities!(@impls [$($rest),*] [$($all),+] [$($done,)* $current]);
    };

    // No wrapping needed (entity is at head).
    (@wrap [] $expr:expr) => { $expr };

    // Wrap in OneOf::There for each entity before the current one.
    (@wrap [$_head:ty $(, $rest:ty)*] $expr:expr) => {
        $crate::OneOf::There($crate::register_entities!(@wrap [$($rest),*] $expr))
    };
}
