//! Type-level dependency lists and computed event types.
//!
//! This module provides the building blocks for declaring which
//! entities a reactor handles and computing the discriminated union
//! event type from that list. Both the [`Reactor`](super::Reactor)
//! trait and the [wiring infrastructure](super::StoreBuilder) depend
//! on these types.
//!
//! # Type-level lists
//!
//! Entity lists are built from [`Cons`] and [`Nil`]:
//! `Cons<A, Cons<B, Nil>>`. The [`deps!`] macro provides sugar:
//! `deps![A, B]`.
//!
//! # Computed event types
//!
//! [`EntityList`] computes a discriminated union event type from
//! the list. `Cons<A, Cons<B, Nil>>` yields
//! `OneOf<(A::Id, A::Event), OneOf<(B::Id, B::Event), Never>>`.
//!
//! Consume events via the [`.on()`](OneOf::on) /
//! [`.exhaustive()`](Fold::exhaustive) chain, which guarantees
//! at compile time that every entity is handled.

use std::future::Future;
use std::marker::PhantomData;
use std::pin::Pin;
use std::sync::Arc;

use crate::EventSourced;
use crate::lifecycle::Never;

/// Type-level cons cell for building linked lists of entities.
///
/// Forms a compile-time linked list:
/// `Cons<Position, Cons<TokenizedEquityMint, Nil>>`.
pub struct Cons<Head, Tail>(PhantomData<(Head, Tail)>);

/// Type-level empty list (nil).
///
/// Terminal element for type-level lists. When an [`Unwired`]
/// reaches this state, [`into_inner`](super::Unwired::into_inner)
/// becomes available.
pub struct Nil;

/// Declares which entities a reactor handles.
///
/// Generated by the statement-position form of [`deps!`]:
///
/// ```ignore
/// deps!(RebalancingTrigger, [Position, TokenizedEquityMint]);
/// ```
///
/// This also generates [`HasEntity`] impls for each entity,
/// enabling ergonomic [`ReactorHarness::receive`] calls.
pub trait Dependent: Send + Sync {
    /// Type-level list of entities this reactor handles.
    type Dependencies: EntityList;
}

/// Enables sharing a `Dependent` impl via `Arc`.
impl<R: Dependent> Dependent for Arc<R> {
    type Dependencies = R::Dependencies;
}

/// Trait on type-level entity lists that computes the
/// discriminated union event type.
///
/// `Cons<A, Cons<B, Nil>>` yields
/// `OneOf<(A::Id, A::Event), OneOf<(B::Id, B::Event), Never>>`.
pub trait EntityList {
    type Event: Send;
}

impl EntityList for Nil {
    type Event = Never;
}

impl<Head: EventSourced, Tail: EntityList> EntityList for Cons<Head, Tail> {
    type Event = OneOf<(Head::Id, Head::Event), Tail::Event>;
}

/// Discriminated union of entity events, computed from a
/// type-level entity list.
///
/// `Cons<A, Cons<B, Nil>>` yields
/// `OneOf<(A::Id, A::Event), OneOf<(B::Id, B::Event), Never>>`.
///
/// Consume via the [`.on()`](Self::on) chain:
///
/// ```ignore
/// event
///     .on(|id, event| async move { self.on_a(id, event).await })
///     .on(|id, event| async move { self.on_b(id, event).await })
///     .exhaustive()
///     .await
/// ```
pub enum OneOf<Head, Tail> {
    Here(Head),
    There(Tail),
}

impl<Id, Event, Tail> OneOf<(Id, Event), Tail> {
    /// Handle the head entity in the union.
    ///
    /// The handler returns a future, which is boxed to unify
    /// types across all handlers in the chain. Call
    /// [`.exhaustive()`](Fold::exhaustive) after all handlers,
    /// then `.await` the result.
    pub fn on<'a, T, F, Fut>(self, handler: F) -> Fold<BoxFuture<'a, T>, Tail>
    where
        F: FnOnce(Id, Event) -> Fut,
        Fut: Future<Output = T> + Send + 'a,
    {
        match self {
            Self::Here((id, event)) => Fold::Done(Box::pin(handler(id, event))),
            Self::There(tail) => Fold::Remaining(tail),
        }
    }
}

impl<A> OneOf<A, Never> {
    /// Unwrap a single-entity event.
    ///
    /// Convenience for `Dependencies = deps![Entity]` where the
    /// computed event is `OneOf<(Id, Event), Never>`.
    pub fn into_inner(self) -> A {
        match self {
            Self::Here(inner) => inner,
            Self::There(never) => match never {},
        }
    }
}

/// Intermediate result from folding handlers over a [`OneOf`]
/// chain.
///
/// `Done(T)` means a handler already matched. `Remaining(tail)`
/// means no handler matched yet and more `.on()` calls are
/// needed. When the tail is [`Never`],
/// [`.exhaustive()`](Self::exhaustive) extracts the result.
pub enum Fold<T, Remaining> {
    Done(T),
    Remaining(Remaining),
}

/// Boxed future used for type erasure across `.on()` handler chains.
type BoxFuture<'a, T> = Pin<Box<dyn Future<Output = T> + Send + 'a>>;

impl<'a, T, Id, Event, Tail> Fold<BoxFuture<'a, T>, OneOf<(Id, Event), Tail>> {
    /// Handle the next entity in the union.
    ///
    /// The handler returns a future, which is boxed to match
    /// the type established by the first `.on()` call.
    pub fn on<F, Fut>(self, handler: F) -> Fold<BoxFuture<'a, T>, Tail>
    where
        F: FnOnce(Id, Event) -> Fut,
        Fut: Future<Output = T> + Send + 'a,
    {
        match self {
            Fold::Done(fut) => Fold::Done(fut),
            Fold::Remaining(one_of) => match one_of {
                OneOf::Here((id, event)) => Fold::Done(Box::pin(handler(id, event))),
                OneOf::There(tail) => Fold::Remaining(tail),
            },
        }
    }
}

impl<T> Fold<T, Never> {
    /// Extract the result once all entities are handled.
    ///
    /// Only available when every entity in the chain has a
    /// corresponding `.on()` handler -- [`Never`] guarantees
    /// exhaustiveness at compile time.
    pub fn exhaustive(self) -> T {
        match self {
            Self::Done(result) => result,
            Self::Remaining(never) => match never {},
        }
    }
}

/// Type-level zero (Peano numeral).
///
/// Used by the wiring infrastructure to track how many entities
/// have been wired. Consumers never need to name this directly.
pub struct Zero;

/// Type-level successor (Peano numeral).
///
/// Used by the wiring infrastructure to track how many entities
/// have been wired. Consumers never need to name this directly.
pub struct Successor<N>(PhantomData<N>);

/// Inject an entity's (Id, Event) pair at a specific depth
/// in the computed event type.
///
/// Used internally by the wiring infrastructure. Consumers
/// never need to reference this trait directly.
pub trait InjectAtDepth<Depth>: EntityList {
    type EntityId;
    type EntityEvent;

    fn inject(id: Self::EntityId, event: Self::EntityEvent) -> Self::Event;
}

impl<Head: EventSourced, Tail: EntityList> InjectAtDepth<Zero> for Cons<Head, Tail> {
    type EntityId = Head::Id;
    type EntityEvent = Head::Event;

    fn inject(id: Head::Id, event: Head::Event) -> Self::Event {
        OneOf::Here((id, event))
    }
}

impl<Head: EventSourced, Tail: EntityList + InjectAtDepth<N>, N> InjectAtDepth<Successor<N>>
    for Cons<Head, Tail>
{
    type EntityId = <Tail as InjectAtDepth<N>>::EntityId;
    type EntityEvent = <Tail as InjectAtDepth<N>>::EntityEvent;

    fn inject(id: Self::EntityId, event: Self::EntityEvent) -> Self::Event {
        OneOf::There(<Tail as InjectAtDepth<N>>::inject(id, event))
    }
}

/// Inject an entity's (Id, Event) pair by entity type.
///
/// Generated by [`register_entities!`] for each entity in
/// the list. Enables `harness.receive::<MyEntity>(id, event)`
/// without specifying position indices or Peano depths.
pub trait HasEntity<Entity: EventSourced>: EntityList {
    fn inject(id: Entity::Id, event: Entity::Event) -> Self::Event;
}

/// Build a type-level dependency list from entity types.
///
/// Has two forms, distinguished by syntax:
///
/// ## Type-position: `deps![...]`
///
/// Expands to a nested `Cons<..., Nil>` type. Use for
/// `Unwired` type annotations and manual `Dependent` impls:
///
/// ```ignore
/// let reactor: Unwired<MyReactor, deps![A, B]> = ...;
/// ```
///
/// ## Statement-position: `deps!(Reactor, [...])`
///
/// Generates a [`Dependent`] impl (setting `Dependencies`)
/// and [`HasEntity`] impls for each entity. This is the
/// primary form -- the entity list is written once:
///
/// ```ignore
/// deps!(EventBroadcaster, [
///     TokenizedEquityMint,
///     EquityRedemption,
///     UsdcRebalance,
/// ]);
///
/// impl Reactor for EventBroadcaster {
///     // Dependencies comes from Dependent -- no duplication
///     type Error = Never;
///
///     async fn react(
///         &self,
///         event: <Self::Dependencies as EntityList>::Event,
///     ) -> Result<(), Self::Error> { ... }
/// }
/// ```
#[macro_export]
macro_rules! deps {
    // Statement-position: generate Dependent + HasEntity impls.
    ($reactor:ty, [$($entity:ty),+ $(,)?]) => {
        impl $crate::Dependent for $reactor {
            type Dependencies = $crate::deps![$($entity),+];
        }
        $crate::register_entities!($($entity),+);
    };

    // Type-position: expand to Cons chain.
    () => { $crate::Nil };
    ($head:ty $(, $tail:ty)* $(,)?) => {
        $crate::Cons<$head, $crate::deps![$($tail),*]>
    };
}

/// Generate [`HasEntity`] impls for each entity in a list.
///
/// This is the low-level building block used by the
/// statement-position form of [`deps!`]. Prefer using `deps!`
/// directly, which generates both [`Dependent`] and [`HasEntity`]
/// impls in one call.
///
/// Only use this directly for generic `Reactor` impls (like
/// [`SpyReactor`]) where `deps!` can't generate the `Dependent`
/// impl.
#[macro_export]
macro_rules! register_entities {
    ($($entity:ty),+ $(,)?) => {
        $crate::register_entities!(@impls [$($entity),+] [$($entity),+] []);
    };

    // All entities processed.
    (@impls [] [$($all:ty),+] [$($done:ty),*]) => {};

    // Generate HasEntity for the current entity, then recurse.
    (@impls [$current:ty $(, $rest:ty)*] [$($all:ty),+] [$($done:ty),*]) => {
        impl $crate::HasEntity<$current> for $crate::deps![$($all),+] {
            fn inject(
                id: <$current as $crate::EventSourced>::Id,
                event: <$current as $crate::EventSourced>::Event,
            ) -> <Self as $crate::EntityList>::Event {
                $crate::register_entities!(@wrap [$($done),*] $crate::OneOf::Here((id, event)))
            }
        }

        $crate::register_entities!(@impls [$($rest),*] [$($all),+] [$($done,)* $current]);
    };

    // No wrapping needed (entity is at head).
    (@wrap [] $expr:expr) => { $expr };

    // Wrap in OneOf::There for each entity before the current one.
    (@wrap [$_head:ty $(, $rest:ty)*] $expr:expr) => {
        $crate::OneOf::There($crate::register_entities!(@wrap [$($rest),*] $expr))
    };
}

#[cfg(test)]
mod tests {
    use async_trait::async_trait;
    use cqrs_es::DomainEvent;
    use serde::{Deserialize, Serialize};

    use super::*;
    use crate::Table;

    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    struct Alpha {
        tag: String,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    enum AlphaEvent {
        Born,
    }

    impl DomainEvent for AlphaEvent {
        fn event_type(&self) -> String {
            "AlphaBorn".into()
        }
        fn event_version(&self) -> String {
            "1".into()
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, thiserror::Error)]
    #[error("alpha error")]
    struct AlphaError;

    #[async_trait]
    impl EventSourced for Alpha {
        type Id = String;
        type Event = AlphaEvent;
        type Command = ();
        type Error = AlphaError;
        type Services = ();

        const AGGREGATE_TYPE: &'static str = "Alpha";
        const PROJECTION: Option<Table> = None;
        const SCHEMA_VERSION: u64 = 1;

        fn originate(event: &AlphaEvent) -> Option<Self> {
            match event {
                AlphaEvent::Born => Some(Self {
                    tag: "alpha".into(),
                }),
            }
        }

        fn evolve(_: &Self, _: &AlphaEvent) -> Result<Option<Self>, AlphaError> {
            Ok(None)
        }

        async fn initialize((): (), (): &()) -> Result<Vec<AlphaEvent>, AlphaError> {
            Ok(vec![AlphaEvent::Born])
        }

        async fn transition(&self, (): (), (): &()) -> Result<Vec<AlphaEvent>, AlphaError> {
            Ok(vec![])
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    struct Beta {
        tag: String,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    enum BetaEvent {
        Spawned,
    }

    impl DomainEvent for BetaEvent {
        fn event_type(&self) -> String {
            "BetaSpawned".into()
        }
        fn event_version(&self) -> String {
            "1".into()
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, thiserror::Error)]
    #[error("beta error")]
    struct BetaError;

    #[async_trait]
    impl EventSourced for Beta {
        type Id = String;
        type Event = BetaEvent;
        type Command = ();
        type Error = BetaError;
        type Services = ();

        const AGGREGATE_TYPE: &'static str = "Beta";
        const PROJECTION: Option<Table> = None;
        const SCHEMA_VERSION: u64 = 1;

        fn originate(event: &BetaEvent) -> Option<Self> {
            match event {
                BetaEvent::Spawned => Some(Self { tag: "beta".into() }),
            }
        }

        fn evolve(_: &Self, _: &BetaEvent) -> Result<Option<Self>, BetaError> {
            Ok(None)
        }

        async fn initialize((): (), (): &()) -> Result<Vec<BetaEvent>, BetaError> {
            Ok(vec![BetaEvent::Spawned])
        }

        async fn transition(&self, (): (), (): &()) -> Result<Vec<BetaEvent>, BetaError> {
            Ok(vec![])
        }
    }

    crate::register_entities!(Alpha, Beta);

    type TwoEntityList = deps![Alpha, Beta];

    #[test]
    fn single_entity_into_inner() {
        type SingleList = deps![Alpha];
        let event = <SingleList as InjectAtDepth<Zero>>::inject("a1".to_string(), AlphaEvent::Born);
        let (id, inner_event) = event.into_inner();
        assert_eq!(id, "a1");
        assert_eq!(inner_event, AlphaEvent::Born);
    }

    #[test]
    fn inject_at_depth_zero_produces_here() {
        let event =
            <TwoEntityList as InjectAtDepth<Zero>>::inject("a1".to_string(), AlphaEvent::Born);
        assert!(matches!(event, OneOf::Here(_)));
    }

    #[test]
    fn inject_at_depth_one_produces_there_here() {
        let event = <TwoEntityList as InjectAtDepth<Successor<Zero>>>::inject(
            "b1".to_string(),
            BetaEvent::Spawned,
        );
        assert!(matches!(event, OneOf::There(OneOf::Here(_))));
    }

    #[test]
    fn has_entity_inject_alpha() {
        let event = <TwoEntityList as HasEntity<Alpha>>::inject("a1".to_string(), AlphaEvent::Born);
        assert!(matches!(event, OneOf::Here(_)));
    }

    #[test]
    fn has_entity_inject_beta() {
        let event =
            <TwoEntityList as HasEntity<Beta>>::inject("b1".to_string(), BetaEvent::Spawned);
        assert!(matches!(event, OneOf::There(OneOf::Here(_))));
    }

    #[tokio::test]
    async fn on_chain_handles_alpha_event() {
        let event = <TwoEntityList as HasEntity<Alpha>>::inject("a1".to_string(), AlphaEvent::Born);

        let result = event
            .on(|id, event| async move { format!("alpha:{id}:{event:?}") })
            .on(|id, event| async move { format!("beta:{id}:{event:?}") })
            .exhaustive()
            .await;

        assert_eq!(result, "alpha:a1:Born");
    }

    #[tokio::test]
    async fn on_chain_handles_beta_event() {
        let event =
            <TwoEntityList as HasEntity<Beta>>::inject("b1".to_string(), BetaEvent::Spawned);

        let result = event
            .on(|id, event| async move { format!("alpha:{id}:{event:?}") })
            .on(|id, event| async move { format!("beta:{id}:{event:?}") })
            .exhaustive()
            .await;

        assert_eq!(result, "beta:b1:Spawned");
    }
}
